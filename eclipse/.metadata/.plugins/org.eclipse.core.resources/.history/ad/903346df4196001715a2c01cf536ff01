package thewizardmod.fluids;

import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.VertexBuffer;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.item.ItemStack;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.capability.CapabilityFluidHandler;
import net.minecraftforge.fluids.capability.IFluidHandler;

import org.lwjgl.opengl.GL11;

import thewizardmod.Util.CapabilityUtils;
import thewizardmod.items.StartupCommon;

public class RendererTank extends TileEntitySpecialRenderer<TileEntityTank>{

	public EntityItem ITEM = new EntityItem(Minecraft.getMinecraft().theWorld, 0, 0, 0, new ItemStack(StartupCommon.magicGem));
	
	@Override
	public void renderTileEntityAt(TileEntityTank te, double x, double y, double z, float partialTicks, int destroyStage) {
		World world = getWorld();
        GlStateManager.pushMatrix();
        int capacity = getFluidHandler(world, new BlockPos(x, y, z)).getCapacity();
        FluidStack fluid = te.getFluidHandler().getFluid();
        if (fluid != null)
        {
            Tessellator tess = Tessellator.getInstance();
            VertexBuffer buffer = tess.getBuffer();

            buffer.setTranslation(x, y, z);

            bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
            TextureAtlasSprite still = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(fluid.getFluid().getStill().toString());
            TextureAtlasSprite flow =  Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(fluid.getFluid().getFlowing().toString());

            double posY = .1 + (.8 * ((float) fluid.amount / (float) capacity));
            float[] color = {255, 0, 100};

            buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_COLOR);
            buffer.pos( 4F/16F, posY,  4F/16F).tex(still.getInterpolatedU( 4), still.getInterpolatedV( 4)).color(color[0], color[1], color[2], color[3]).endVertex();
            buffer.pos(12F/16F, posY,  4F/16F).tex(still.getInterpolatedU(12), still.getInterpolatedV( 4)).color(color[0], color[1], color[2], color[3]).endVertex();
            buffer.pos(12F/16F, posY, 12F/16F).tex(still.getInterpolatedU(12), still.getInterpolatedV(12)).color(color[0], color[1], color[2], color[3]).endVertex();
            buffer.pos( 4F/16F, posY, 12F/16F).tex(still.getInterpolatedU( 4), still.getInterpolatedV(12)).color(color[0], color[1], color[2], color[3]).endVertex();
            tess.draw();

            buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_COLOR);
            buffer.pos(12F/16F, 1F/16F, 12F/16F).tex(flow.getInterpolatedU(12), flow.getInterpolatedV(15)).color(color[0], color[1], color[2], color[3]).endVertex();
            buffer.pos(12F/16F, posY, 12F/16F).tex(flow.getInterpolatedU(12), flow.getInterpolatedV( 1)).color(color[0], color[1], color[2], color[3]).endVertex();
            buffer.pos( 4F/16F, posY, 12F/16F).tex(flow.getInterpolatedU( 4), flow.getInterpolatedV( 1)).color(color[0], color[1], color[2], color[3]).endVertex();
            buffer.pos( 4F/16F, 1F/16F, 12F/16F).tex(flow.getInterpolatedU( 4), flow.getInterpolatedV(15)).color(color[0], color[1], color[2], color[3]).endVertex();
            tess.draw();

            buffer.setTranslation(0, 0, 0);
        }
        GlStateManager.popMatrix();
	
	}
	
	private IFluidHandler getFluidHandler(IBlockAccess world, BlockPos pos) {
		return CapabilityUtils.getCapability(world.getTileEntity(pos), CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY, null);
	}

}
