package thewizardmod.mirror;

import java.util.List;

import javax.annotation.Nullable;

import thewizardmod.magicInjector.TileEntityMagicInjector;

import net.minecraft.block.Block;
import net.minecraft.block.ITileEntityProvider;
import net.minecraft.block.material.Material;
import net.minecraft.block.properties.IProperty;
import net.minecraft.block.properties.PropertyDirection;
import net.minecraft.block.state.BlockStateContainer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.creativetab.CreativeTabs;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockRenderLayer;
import net.minecraft.util.EnumBlockRenderType;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class Mirror extends Block implements ITileEntityProvider{
	private static final AxisAlignedBB BOUNCING_BOX = new AxisAlignedBB(0.0625 * 0, 0, 0.0625 * 0, 0.0625 * 16, 0.0625 * 16, 0.0625 * 2);
	private static final AxisAlignedBB COLLISION_BOX = new AxisAlignedBB(0.0625 * 0, 0, 0.0625 * 0, 0.0625 * 16, 0.0625 * 16, 0.0625 * 2);
	public static final PropertyDirection PROPERTYFACING = PropertyDirection.create("facing", EnumFacing.Plane.HORIZONTAL);

	
	public static EnumFacing FACING;
	
	public Mirror() {
		super(Material.GLASS);
		this.setCreativeTab(CreativeTabs.MISC);
		this.setDefaultState(this.blockState.getBaseState().withProperty(PROPERTYFACING, EnumFacing.NORTH));
		setHardness(3.0F);
		setResistance(5.0F);

	}

	// the block will render in the SOLID layer. See
	// http://greyminecraftcoder.blogspot.co.at/2014/12/block-rendering-18.html
	// for more information.
	@SideOnly(Side.CLIENT)
	public BlockRenderLayer getBlockLayer() {
		return BlockRenderLayer.TRANSLUCENT;
	}

	// used by the renderer to control lighting and visibility of other blocks.
	// set to true because this block is opaque and occupies the entire 1x1x1
	// space
	// not strictly required because the default (super method) is true
	@Override
	public boolean isOpaqueCube(IBlockState iBlockState) {
		return false;
	}

	// used by the renderer to control lighting and visibility of other blocks,
	// also by
	// (eg) wall or fence to control whether the fence joins itself to this
	// block
	// set to true because this block occupies the entire 1x1x1 space
	// not strictly required because the default (super method) is true
	@Override
	public boolean isFullCube(IBlockState iBlockState) {
		return false;
	}

	// not strictly required because the default (super method) is MODEL.
	@Override
	public EnumBlockRenderType getRenderType(IBlockState iBlockState) {
		return EnumBlockRenderType.MODEL;
	}
	
	  @Override
	  public TileEntity createNewTileEntity(World worldIn, int meta) {
		return new TileEntityMirror();
	  }

	  @Override
	  @Deprecated
	  public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
		  return BOUNCING_BOX;
	  }
	  
	  @Override
	  @Deprecated
	  public void addCollisionBoxToList(IBlockState state, World worldIn, BlockPos pos, AxisAlignedBB entityBox, List<AxisAlignedBB> collidingBoxes, @Nullable Entity entityIn) {
		  super.addCollisionBoxToList(pos, entityBox, collidingBoxes, COLLISION_BOX);
	  }

		@Override
		public IBlockState onBlockPlaced(World worldIn, BlockPos pos, EnumFacing blockFaceClickedOn, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer)
		{
			  // find the quadrant the player is facing
			EnumFacing enumfacing = (placer == null) ? EnumFacing.NORTH : EnumFacing.fromAngle(placer.rotationYaw);
			
			FACING = enumfacing;

			TileEntity tileEntity = worldIn.getTileEntity(pos);
			if (tileEntity instanceof TileEntityMirror) {
				int facing = MathHelper.floor_double((double) ((placer.rotationYaw * 4F) / 360F) + 0.5D) & 3;
				((TileEntityMirror) tileEntity).setFacing(facing);
			}
			  // Place allways same up and down direction
			return this.getDefaultState().withProperty(PROPERTYFACING, enumfacing);
			  // Place like a dispenser
			  // return this.getDefaultState().withProperty(PROPERTYFACING, BlockPistonBase.getFacingFromEntity(pos, placer));
			  
		}		  		
		// here we have to update the block state depending on the activity state
		@Override
		public IBlockState getActualState(IBlockState state, IBlockAccess worldIn, BlockPos pos)
		{
			return state;
		}

		@Override
		public IBlockState getStateFromMeta(int meta)
		{
			return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.getHorizontal(meta));
		}

		@Override
		public int getMetaFromState(IBlockState state)
		{
			return state.getValue(PROPERTYFACING).getHorizontalIndex();
		}

		// necessary to define which properties your blocks use
		@Override
		protected BlockStateContainer createBlockState()
		{
			return new BlockStateContainer(this, new IProperty[] {PROPERTYFACING});
		}

}
